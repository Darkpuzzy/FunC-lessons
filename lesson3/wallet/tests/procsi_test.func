{-
    main и recv_internal имеют id = 0
    recv_external имеют id = -1
    run_ticktock имеют id = -2 
-}


int equal_slices (slice a, slice b) asm "SDEQ";

;; DATA FUNCTIONS 

[int, tuple, cell, tuple, int] proxi_test_data() method_id(0) {
    ;; external addr  begin_parse() -> slice store_uint(int, int) - writen in cell
    ;; len = 5
    ;; 7 is my addr
    int function_selector = 0;

    cell my_addr = begin_cell()
                            .store_uint(1, 2)
                            .store_uint(5, 9)
                            .store_uint(7, 5)
                            .end_cell();

    cell their_address = begin_cell()
        .store_uint(1, 2)
        .store_uint(5, 9) 
        .store_uint(8, 5) ;; 8 owner_addr
        .end_cell();

    slice message_body = begin_cell().store_uint(12345, 32).end_cell().begin_parse();

    cell message = begin_cell()
        .store_uint(0x6, 4)
        .store_slice(their_address.begin_parse()) 
		.store_slice(their_address.begin_parse()) 
		.store_grams(100)
		.store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
		.store_slice(message_body)
		.end_cell();

    ;; int balance, int msg_value, cell in_msg_full, slice in_msg_body
    tuple stack = unsafe_tuple([12345, 100, message, message_body]);

    return [function_selector, stack, my_addr, get_c7(), null()];
}

;; After test data function
;; We need to define test funtion
;; It will accept:
;;        exit code - exit code of runvm, here you can check errors / not
;;        c4 cell - data of smart contract after runvm invokes
;;        tuple - stack values of smart contract
;;        c5 cell - here you can check all outcoming messages
;;        gas - gas that was used
;; By default test is passed
;; You can use throw_if to fail test

_ test_proxi(int exit_code, cell data, tuple stack, cell actions, int gas) method_id(1) {
    throw_if(100, exit_code != 0);

    slice actions = actions.begin_parse();
    throw_if(101, actions~load_uint(32) != 0x0ec3c86d); 

    throw_if(102, ~ slice_empty?(actions~load_ref().begin_parse())); 

    slice msg = actions~load_ref().begin_parse();
    throw_if(103, msg~load_uint(6) != 0x10);

    slice send_to_address = msg~load_msg_addr();
    slice expected_my_addr = begin_cell().store_uint(1, 2).store_uint(5, 9).store_uint(7, 5).end_cell().begin_parse();

    throw_if(104, ~ equal_slices(expected_my_addr, send_to_address));
    throw_if(105, msg~load_grams() != 0);
    throw_if(106, msg~load_uint(1 + 4 + 4 + 64 + 32 + 1 + 1) != 0);

    slice sender_address = msg~load_msg_addr();
    slice expected_sender_address = begin_cell().store_uint(1, 2).store_uint(5, 9).store_uint(8, 5).end_cell().begin_parse();
    throw_if(107, ~ equal_slices(sender_address, expected_sender_address));

    slice fwd_msg = msg~load_ref().begin_parse();

    throw_if(108, fwd_msg~load_uint(32) != 12345);
    fwd_msg.end_parse();

    msg.end_parse();
}



[int, tuple, cell, tuple, int] test_same_addr_data() method_id(2) {
    ;; Funtion to run (recv_internal)
    int function_selector = 0;

    cell my_addres = begin_cell()
                            .store_uint(1, 2) 
                            .store_uint(5, 9) 
                            .store_uint(7, 5) 
                            .end_cell();

    slice message_body = begin_cell().store_uint(12345, 32).end_cell().begin_parse();


    cell message = begin_cell()
            .store_uint(0x6, 4)
            .store_slice(my_addres.begin_parse()) ;; src address
            .store_slice(my_addres.begin_parse()) ;; should be contract address
            .store_grams(100)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_slice(message_body)
            .end_cell();

    tuple stack = unsafe_tuple([12345, 100, message, message_body]);

    return [function_selector, stack, my_addres, get_c7(), null()];
}


;; After test data function
;; We need to define test funtion
;; It will accept:
;;        exit code - exit code of runvm, here you can check errors / not
;;        c4 cell - data of smart contract after runvm invokes
;;        tuple - stack values of smart contract
;;        c5 cell - here you can check all outcoming messages
;;        gas - gas that was used
;; By default test is passed
;; You can use throw_if to fail test

_ test_same_addr(int exit_code, cell data, tuple stack, cell actions, int gas) method_id(3) {
    throw_if(100, exit_code != 0);

    throw_if(102, ~ slice_empty?(actions.begin_parse()));

}

(int, cell) extract_single_message(cell actions) impure inline method_id {
	;; ---------------- Parse actions list
	;; prev:^(OutList n)
	;; #0ec3c86d
	;; mode:(## 8)
	;; out_msg:^(MessageRelaxed Any)
	;; = OutList (n + 1);
	slice cs = actions.begin_parse();
	throw_unless(1010, cs.slice_refs() == 2);
	
	cell prev_actions = cs~load_ref();
	throw_unless(1011, prev_actions.cell_empty?());
	
	int action_type = cs~load_uint(32);
	throw_unless(1013, action_type == 0x0ec3c86d);
	
	int msg_mode = cs~load_uint(8);
	throw_unless(1015, msg_mode == 64); 
	
	cell msg = cs~load_ref();
	throw_unless(1017, cs.slice_empty?());
	
	return (msg_mode, msg);
}